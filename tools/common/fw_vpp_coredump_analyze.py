#! /usr/bin/python3

################################################################################
# flexiWAN SD-WAN software - flexiEdge, flexiManage.
# For more information go to https://flexiwan.com
#
# Copyright (C) 2021  flexiWAN Ltd.
#
# This program is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
################################################################################
#
# Tested to work in python3.6
#
# The script takes the vpp coredump as input (tar.gz file generated by flexiagent)
# It downloads required packages and debug info and sets up workspace folder to
# analyze the core.

import argparse
import glob
import os
import shutil
import subprocess
import sys
import tarfile
import urllib.request
import yaml
import traceback

FW_PKG_URL = "https://deb.flexiwan.com/flexiWAN/pool/%s/f/flexiwan-router/"
FW_PKG_RTR = "flexiwan-router_%s.%s_amd64.deb"
FW_PKG_RTR_DBG = "flexiwan-router-dbg_%s.%s_amd64.deb"

FW_VPP_CORE_GDB_SOLIB_PATH = "/usr/lib/x86_64-linux-gnu/:/lib/x86_64-linux-gnu/"
FW_VPP_CORE_GDB_DEBUG_PATH = "/usr/lib/debug/"
FW_VPP_CORE_GDB_SETUP =\
        "set solib-absolute-prefix %s\n" +\
        "set solib-search-path %s" + ":" + FW_VPP_CORE_GDB_SOLIB_PATH +"\n" +\
        "set debug-file-directory %s" + FW_VPP_CORE_GDB_DEBUG_PATH +\
            ":" + FW_VPP_CORE_GDB_DEBUG_PATH + "\n" +\
        "file %s/usr/bin/vpp\n" +\
        "core-file %s\n"

FW_VPP_CORE_GDB_SCRIPT = "fw_vpp_setup.gdb"

FW_VPP_CORE_GDB_BT_INFO=\
        "set logging overwrite on\n"+\
        "set logging on\n"+\
        "echo ================== Backtrace  ====================\\n\n"+\
        "backtrace\n"+\
        "echo \\n\n"+\
        "echo ================== ThreadInfo ====================\\n\n"+\
        "info threads\n"+\
        "echo \\n\n"+\
        "echo ============= All thread backtraces ==============\\n\n"+\
        "thread apply all backtrace full\n"+\
        "echo \\n\n"+\
        "echo =============== Shared library info ==============\\n\n"+\
        "info sharedlibrary\n"+\
        "echo \\n\n"


class FwVppCoredumpAnalyze():

    @staticmethod
    def __extract_corefile(compressed_corefile, work_dir):
        corefile_tar = tarfile.open(compressed_corefile)
        file_list = corefile_tar.getnames()
        print("INFO: Extracting compressed corefile input: %s" % (compressed_corefile))
        corefile_tar.extractall(work_dir)
        corefile_tar.close()
        return file_list


    @staticmethod
    def __get_pkg_version(fw_version_file):
        # Fetch flexiwan version info from fwagent version file
        with open(fw_version_file, 'r') as version_data:
            version_info = yaml.safe_load(version_data)
            return version_info['device']


    @staticmethod
    def __get_fw_build_info(fw_repo_file):
        with open(fw_repo_file, 'r') as build_data:
            # Example: deb [ arch=amd64 ] https://deb.flexiwan.com/flexiWAN bionic main
            # Extract: 'bionic' and 'main' as os_release_type and repo_name
            build_info = build_data.readline()
            build_info_parse = build_info.split()
            return build_info_parse[5], build_info_parse[6]


    @staticmethod
    def __fetch_build_pkg(fw_version, fw_repo, os_release, work_dir):
        url = FW_PKG_URL % (fw_repo)
        router_deb = FW_PKG_RTR % (fw_version, os_release)
        router_dbg_deb = FW_PKG_RTR_DBG % (fw_version, os_release)
        router_fetch_path = work_dir + "/" + router_deb
        router_dbg_fetch_path = work_dir + "/" + router_dbg_deb
        if os.path.exists(router_fetch_path):
            print("INFO: Router package exists in workspace - Skip download: %s" % router_deb)
        else:
            print("INFO: Downloading package: %s" % (url + router_deb))
            urllib.request.urlretrieve((url + router_deb), router_fetch_path)
        if os.path.exists(router_dbg_fetch_path):
            print("INFO: Symbol package exists in workspace - Skip download: %s" % router_dbg_deb)
        else:
            print("INFO: Downloading package: %s" % (url + router_dbg_deb))
            urllib.request.urlretrieve((url + router_dbg_deb), router_dbg_fetch_path)
        command = ['dpkg-deb', '-x']
        command.append(router_fetch_path)
        command.append(work_dir)
        print("INFO: Extracting package: %s" % (router_fetch_path))
        subprocess.run(command) #Can throw CalledProcessError
        command = ['dpkg-deb', '-x']
        command.append(router_dbg_fetch_path)
        command.append(work_dir)
        print("INFO: Extracting package: %s" % (router_dbg_fetch_path))
        subprocess.run(command) #Can throw CalledProcessError
        return


    @staticmethod
    def __perform_gdb_processing(vpp_coredump_file, work_dir, dump_backtrace_only):

        out = FW_VPP_CORE_GDB_SETUP % (work_dir, work_dir, work_dir, work_dir,
            (work_dir + vpp_coredump_file))
        if not dump_backtrace_only:
            gdb_setup_file = work_dir + FW_VPP_CORE_GDB_SCRIPT
            with open(gdb_setup_file, 'w') as gdb_setup_script:
                gdb_setup_script.write(out)
        else:
            out += FW_VPP_CORE_GDB_BT_INFO
            gdb_bt_command_file = work_dir + "fw_vpp_bt.gdb"
            with open(gdb_bt_command_file, 'w') as gdb_bt_fetch:
                gdb_bt_fetch.write(out)

            gdb_command = ['gdb', '-nx', '-batch', '-x']
            gdb_command.append(gdb_bt_command_file)
            gdb_log_file = "./gdb.log"
            with open(gdb_log_file, "w") as gdb_log:
                subprocess.run(gdb_command, stdout=gdb_log, stderr=gdb_log)


    def setup_workspace(self, compressed_corefile, work_dir, dump_backtrace_only):

        try:
            file_list = self.__extract_corefile(compressed_corefile, work_dir)
            fw_version_file = None
            fw_repo_file = None
            vpp_coredump_file = None
            print("INFO: Files extracted:")
            for filename in file_list:
                if filename.startswith("fw_version-") and filename.endswith(".yaml"):
                    fw_version_file = filename
                elif filename.startswith("fw_repo-") and filename.endswith(".list"):
                    fw_repo_file = filename
                elif filename.startswith("core-vpp"):
                    vpp_coredump_file = filename
                print("\t%s" % (filename))
            if not fw_version_file or not fw_repo_file or not vpp_coredump_file:
                print("ERROR: Not all required files found in coredump input file")
                exit(-1)
            fw_version = self.__get_pkg_version(work_dir + "/" + fw_version_file)
            os_release, fw_repo = self.__get_fw_build_info(work_dir + "/" + fw_repo_file)
            print("INFO: Version: %s  Repo: %s  OS_Release: %s" % (fw_version, fw_repo, os_release))
            self.__fetch_build_pkg(fw_version, fw_repo, os_release, work_dir)
            self.__perform_gdb_processing(vpp_coredump_file, work_dir, dump_backtrace_only)
        except Exception as e:
            print ("ERROR: coredump workspace setup failed : - %s Traceback: %s" %
                    (str(e), str(traceback.format_exc())))
            return False
        return True


if __name__ == '__main__':

    parser = argparse.ArgumentParser(description='Tool to setup coredump analysis workspace')
    parser.add_argument('-f', '--fw_corefile', default=None, required=True,
                        help="Provide compressed VPP coredump file generated by fwagent")

    #This option can be used to get a text backtrace
    #Use case: QE/Support can use the text backtrace to check if it is a new or existing issue
    parser.add_argument('-d', '--dump_backtrace_only', action='store_true',
                        help="Dump a text backtrace of coredump")
    args = parser.parse_args()

    if args.dump_backtrace_only and not shutil.which('gdb'):
        print("ERROR: Install gdb to use dump_backtrace_only option [Ubuntu: apt install gdb]")
        exit(-1)

    fw_corefile = args.fw_corefile
    cwd = os.getcwd()
    if not os.path.isfile(fw_corefile):
        fw_corefile = cwd + "/" + fw_corefile
        if not os.path.isfile(fw_corefile):
            print("ERROR: Input coredump file not found : %s" % args.fw_corefile)
            exit(-1)

    work_dir = cwd + "/" + os.path.basename(fw_corefile) + ".DIR/"
    print("INFO: Created workspace folder: %s" % (work_dir))

    coredump_analysis = FwVppCoredumpAnalyze()
    if (coredump_analysis.setup_workspace(fw_corefile, work_dir, args.dump_backtrace_only)):
        print("INFO: Coredump workspace setup successfully")
        if args.dump_backtrace_only:
            shutil.rmtree(work_dir, ignore_errors=True)
            print("INFO: Cleaned workspace directory %s" % (work_dir))
            print("\nBacktrace Info can be found in ./gdb.txt\n")
        else:
            print("\nTO START analysis, execute below command in Shell\n")
            print("gdb --command=%s%s" % (work_dir, FW_VPP_CORE_GDB_SCRIPT))
    else:
        shutil.rmtree(work_dir, ignore_errors=True)
        print("ERROR: exit: Cleaned up workspace directory %s" % (work_dir))
